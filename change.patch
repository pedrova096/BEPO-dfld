diff --git a/.vscode/settings.json b/.vscode/settings.json
index 619f675..1af7380 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -12,7 +12,8 @@
   "Lua.diagnostics.libraryFiles": "Disable",
   "Lua.diagnostics.disable": ["lowercase-global", "redefined-local"],
   "Lua.workspace.library": [
-    "~/.config/Cursor/User/globalStorage/astronachos.defold"
+    "~/.config/Cursor/User/globalStorage/astronachos.defold",
+    "~/.config/Cursor/User/workspaceStorage/93c883c44d90647edecaf009f5d73be0/astronachos.defold"
   ],
   "files.associations": {
     "*.project": "ini",
diff --git a/main/game/stages/ai_stage_example_config.lua b/main/game/stages/ai_stage_example_config.lua
new file mode 100644
index 0000000..9f2b05d
--- /dev/null
+++ b/main/game/stages/ai_stage_example_config.lua
@@ -0,0 +1,45 @@
+-- 1st wave: Budget-based
+local wave1 = {
+    pattern = "budget",
+    type = "enemies",
+    budget = 50,
+    spent = 0,
+    max_active = 5,
+    enemies = {
+        enemy_01 = { id = "enemy_01", probability = 0.7, threat = 10 },
+        enemy_02 = { id = "enemy_02", probability = 0.3, threat = 20 },
+    }
+}
+
+-- 2nd wave: Time limit, different spawn probabilities
+local wave2 = {
+    pattern = "time",
+    time_limit = 30,
+    elapsed_time = 0,
+    spawn_rate = 2.0, -- Seconds between spawns
+    max_active = 8,
+    enemies = {
+        enemy_01 = { id = "enemy_01", probability = 0.5, threat = 10 },
+        enemy_03 = { id = "enemy_03", probability = 0.5, threat = 15 },
+    }
+}
+
+-- 3rd wave: Budget-based boss
+local wave3 = {
+    pattern = "budget",
+    type = "boss",
+    budget = 100,
+    spent = 0,
+    max_active = 1,
+    enemies = {
+        enemy_04 = { id = "enemy_04", probability = 1.0, threat = 100 },
+    }
+}
+
+local example = {
+    end_condition = "clean_up",
+    inter_wave_delay = 2,
+    waves = { wave1, wave2, wave3 }
+}
+
+return example
diff --git a/render/the.render b/render/the.render
new file mode 100644
index 0000000..6ec3618
--- /dev/null
+++ b/render/the.render
@@ -0,0 +1 @@
+script: "/render/the.render_script"
diff --git a/render/the.render_script b/render/the.render_script
new file mode 100644
index 0000000..5383ac3
--- /dev/null
+++ b/render/the.render_script
@@ -0,0 +1,331 @@
+-- Copyright 2020-2025 The Defold Foundation
+-- Copyright 2014-2020 King
+-- Copyright 2009-2014 Ragnar Svensson, Christian Murray
+-- Licensed under the Defold License version 1.0 (the "License"); you may not use
+-- this file except in compliance with the License.
+--
+-- You may obtain a copy of the License, together with FAQs at
+-- https://www.defold.com/license
+--
+-- Unless required by applicable law or agreed to in writing, software distributed
+-- under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+-- CONDITIONS OF ANY KIND, either express or implied. See the License for the
+-- specific language governing permissions and limitations under the License.
+
+--
+-- message constants
+--
+local MSG_CLEAR_COLOR = hash("clear_color")
+local MSG_WINDOW_RESIZED = hash("window_resized")
+local MSG_SET_VIEW_PROJ = hash("set_view_projection")
+local MSG_SET_CAMERA_PROJ = hash("use_camera_projection")
+local MSG_USE_STRETCH_PROJ = hash("use_stretch_projection")
+local MSG_USE_FIXED_PROJ = hash("use_fixed_projection")
+local MSG_USE_FIXED_FIT_PROJ = hash("use_fixed_fit_projection")
+
+local DEFAULT_NEAR = -1
+local DEFAULT_FAR = 1
+local DEFAULT_ZOOM = 1
+
+--
+-- projection that centers content with maintained aspect ratio and optional zoom
+--
+local function get_fixed_projection(camera, state)
+    camera.zoom = camera.zoom or DEFAULT_ZOOM
+    local projected_width = state.window_width / camera.zoom
+    local projected_height = state.window_height / camera.zoom
+    local left = -(projected_width - state.width) / 2
+    local bottom = -(projected_height - state.height) / 2
+    local right = left + projected_width
+    local top = bottom + projected_height
+    return vmath.matrix4_orthographic(left, right, bottom, top, camera.near, camera.far)
+end
+--
+-- projection that centers and fits content with maintained aspect ratio
+--
+local function get_fixed_fit_projection(camera, state)
+    camera.zoom = math.min(state.window_width / state.width, state.window_height / state.height)
+    return get_fixed_projection(camera, state)
+end
+--
+-- projection that stretches content
+--
+local function get_stretch_projection(camera, state)
+    return vmath.matrix4_orthographic(0, state.width, 0, state.height, camera.near, camera.far)
+end
+--
+-- projection for gui
+--
+local function get_gui_projection(camera, state)
+    return vmath.matrix4_orthographic(0, state.window_width, 0, state.window_height, camera.near, camera.far)
+end
+
+local function update_clear_color(state, color)
+    if color then
+        state.clear_buffers[graphics.BUFFER_TYPE_COLOR0_BIT] = color
+    end
+end
+
+local function update_camera(camera, state)
+    if camera.projection_fn then
+        camera.proj = camera.projection_fn(camera, state)
+        camera.options.frustum = camera.proj * camera.view
+    end
+end
+
+local function update_target(target, state)
+    render.set_render_target_size(target, state.window_width, state.window_height)
+end
+
+local function update_state(state)
+    state.window_width = render.get_window_width()
+    state.window_height = render.get_window_height()
+    state.valid = state.window_width > 0 and state.window_height > 0
+    if not state.valid then
+        return false
+    end
+    -- Make sure state updated only once when resize window
+    if state.window_width == state.prev_window_width and state.window_height == state.prev_window_height then
+        return true
+    end
+    state.prev_window_width = state.window_width
+    state.prev_window_height = state.window_height
+    state.width = render.get_width()
+    state.height = render.get_height()
+    for _, camera in pairs(state.cameras) do
+        update_camera(camera, state)
+    end
+    for _, target in pairs(state.targets) do
+        update_target(target, state)
+    end
+    return true
+end
+
+local function init_camera(camera, projection_fn, near, far, zoom)
+    camera.view = vmath.matrix4()
+    camera.near = near == nil and DEFAULT_NEAR or near
+    camera.far = far == nil and DEFAULT_FAR or far
+    camera.zoom = zoom == nil and DEFAULT_ZOOM or zoom
+    camera.projection_fn = projection_fn
+end
+
+local function create_predicates(...)
+    local arg = { ... }
+    local predicates = {}
+    for _, predicate_name in pairs(arg) do
+        predicates[predicate_name] = render.predicate({ predicate_name })
+    end
+    return predicates
+end
+
+local function create_camera(state, name, is_main_camera)
+    local camera = {}
+    camera.options = {}
+    state.cameras[name] = camera
+    if is_main_camera then
+        state.main_camera = camera
+    end
+    return camera
+end
+
+local function create_render_target(state, name)
+    return render.render_target(name, {
+        [graphics.BUFFER_TYPE_COLOR0_BIT] = {
+            format = graphics.TEXTURE_FORMAT_RGBA,
+            width = state.window_width,
+            height = state.window_height
+        }
+    })
+end
+
+local function create_state()
+    local state = {}
+    local color = vmath.vector4(0, 0, 0, 0)
+    color.x = sys.get_config_number("render.clear_color_red", 0)
+    color.y = sys.get_config_number("render.clear_color_green", 0)
+    color.z = sys.get_config_number("render.clear_color_blue", 0)
+    color.w = sys.get_config_number("render.clear_color_alpha", 0)
+    state.clear_buffers = {
+        [graphics.BUFFER_TYPE_COLOR0_BIT] = color,
+        [graphics.BUFFER_TYPE_DEPTH_BIT] = 1,
+        [graphics.BUFFER_TYPE_STENCIL_BIT] = 0
+    }
+    state.cameras = {}
+    state.targets = {}
+    return state
+end
+
+local function get_camera_world(state)
+    local camera_components = camera.get_cameras()
+
+    -- This will set the last enabled camera from the stack of camera components
+    if #camera_components > 0 then
+        for i = #camera_components, 1, -1 do
+            if camera.get_enabled(camera_components[i]) then
+                local camera_component = state.cameras.camera_component
+                camera_component.camera = camera_components[i]
+                -- render.set_camera(camera_component.camera, { use_frustum = true })
+                -- The frustum will be overridden by the render.set_camera call,
+                -- so we don't need to return anything here other than an empty table.
+                return camera_component
+            end
+        end
+    end
+
+    -- If no active camera was found, we use the default main "camera world" camera
+    local camera_world = state.cameras.camera_world
+    render.set_view(camera_world.view)
+    render.set_projection(camera_world.proj)
+    return camera_world.options
+end
+
+local function reset_camera_world(state)
+    -- unbind the camera if a camera component is used
+    if state.cameras.camera_component.camera then
+        state.cameras.camera_component.camera = nil
+        render.set_camera()
+    end
+end
+
+local function render_to_render_target(render_target, callback)
+    render.set_render_target(render_target)
+    callback()
+    render.set_render_target(render.RENDER_TARGET_DEFAULT)
+end
+
+function init(self)
+    self.predicates = create_predicates("tile", "gui", "particle", "model", "debug_text", "quad")
+
+    -- default is stretch projection. copy from builtins and change for different projection
+    -- or send a message to the render script to change projection:
+    -- msg.post("@render:", "use_stretch_projection", { near = -1, far = 1 })
+    -- msg.post("@render:", "use_fixed_projection", { near = -1, far = 1, zoom = 2 })
+    -- msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })
+
+    local state = create_state()
+    self.state = state
+
+    local camera_world = create_camera(state, "camera_world", true)
+    init_camera(camera_world, get_stretch_projection)
+    local camera_gui = create_camera(state, "camera_gui")
+    init_camera(camera_gui, get_gui_projection)
+    -- Create a special camera that wraps camera components (if they exist)
+    -- It will take precedence over any other camera, and not change from messages
+    create_camera(state, "camera_component")
+    update_state(state)
+    state.targets = {
+        original = create_render_target(state, "original"),
+    }
+end
+
+local function set_default_renderer_state()
+    render.set_depth_mask(false)
+    render.disable_state(render.STATE_DEPTH_TEST)
+    render.disable_state(render.STATE_STENCIL_TEST)
+    render.enable_state(render.STATE_BLEND)
+    render.set_blend_func(render.BLEND_SRC_ALPHA, render.BLEND_ONE_MINUS_SRC_ALPHA)
+    render.disable_state(render.STATE_CULL_FACE)
+end
+
+local IDENTITY_MATRIX = vmath.matrix4()
+
+function update(self)
+    local state = self.state
+    if not state.valid then
+        if not update_state(state) then
+            return
+        end
+    end
+
+    local predicates = self.predicates
+    local targets = state.targets
+
+    -- clear screen buffers
+    --
+    -- turn on depth_mask before `render.clear()` to clear it as well
+    -- render.set_depth_mask(true)
+    -- render.set_stencil_mask(0xff)
+    -- render.clear(state.clear_buffers)
+
+    -- setup camera view and projection
+    --
+    local camera_world = get_camera_world(state)
+    local draw_options_world = camera_world.options
+
+    render.set_viewport(0, 0, state.window_width, state.window_height)
+
+    render_to_render_target(targets.original, function()
+        render.set_view(camera.get_view(camera_world.camera))
+        render.set_projection(camera.get_projection(camera_world.camera))
+        -- clear screen buffers
+        --
+        render.clear(state.clear_buffers)
+        set_default_renderer_state()
+        -- set states used for all the world predicates
+        render.set_blend_func(graphics.BLEND_FACTOR_SRC_ALPHA, graphics.BLEND_FACTOR_ONE_MINUS_SRC_ALPHA)
+        render.enable_state(graphics.STATE_DEPTH_TEST)
+
+        -- render `model` predicate for default 3D material
+        --
+        render.enable_state(graphics.STATE_CULL_FACE)
+        render.draw(predicates.model, draw_options_world)
+        render.set_depth_mask(false)
+        render.disable_state(graphics.STATE_CULL_FACE)
+
+        -- render the other components: sprites, tilemaps, particles etc
+        --
+        render.enable_state(graphics.STATE_BLEND)
+        render.draw(predicates.tile, draw_options_world)
+        render.draw(predicates.particle, draw_options_world)
+        render.disable_state(graphics.STATE_DEPTH_TEST)
+
+        render.draw_debug3d()
+    end)
+
+    set_default_renderer_state()
+    render.clear(state.clear_buffers)
+
+    render.set_view(IDENTITY_MATRIX)
+    render.set_projection(IDENTITY_MATRIX)
+    render.enable_texture(1, state.targets.original)
+    render.draw(predicates.quad, draw_options_world)
+    render.disable_texture(1)
+
+    -- render GUI
+    --
+    local camera_gui = state.cameras.camera_gui
+    render.set_view(camera_gui.view)
+    render.set_projection(camera_gui.proj)
+
+    render.enable_state(graphics.STATE_STENCIL_TEST)
+    render.draw(predicates.gui, camera_gui.options)
+    render.draw(predicates.debug_text, camera_gui.options)
+    render.disable_state(graphics.STATE_STENCIL_TEST)
+    render.disable_state(graphics.STATE_BLEND)
+end
+
+function on_message(self, message_id, message)
+    local state = self.state
+    local camera = state.main_camera
+
+    if message_id == MSG_CLEAR_COLOR then
+        update_clear_color(state, message.color)
+    elseif message_id == MSG_WINDOW_RESIZED then
+        update_state(state)
+    elseif message_id == MSG_SET_VIEW_PROJ then
+        camera.view = message.view
+        self.camera_projection = message.projection or vmath.matrix4()
+        update_camera(camera, state)
+    elseif message_id == MSG_SET_CAMERA_PROJ then
+        camera.projection_fn = function() return self.camera_projection end
+    elseif message_id == MSG_USE_STRETCH_PROJ then
+        init_camera(camera, get_stretch_projection, message.near, message.far)
+        update_camera(camera, state)
+    elseif message_id == MSG_USE_FIXED_PROJ then
+        init_camera(camera, get_fixed_projection, message.near, message.far, message.zoom)
+        update_camera(camera, state)
+    elseif message_id == MSG_USE_FIXED_FIT_PROJ then
+        init_camera(camera, get_fixed_fit_projection, message.near, message.far)
+        update_camera(camera, state)
+    end
+end
